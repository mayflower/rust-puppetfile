// Generated by rust-peg. Do not edit.
#![allow(non_snake_case, unused)]
use std::num::from_str_radix;
use std::char;
use super::*;
use semver::VersionReq;
use semver;
use self::ParseResult::{Matched, Failed};
enum ParseResult<T> { Matched(uint, T), Failed, }
struct ParseState {
    max_err_pos: uint,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: uint, expected: &'static str)
     -> ParseResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: uint, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           input.as_bytes().slice(pos, pos + l) == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn any_char(input: &str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: uint) -> (uint, uint) {
    let mut remaining = pos;
    let mut lineno: uint = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
fn parse_parse<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Puppetfile> {
    {
        let start_pos = pos;
        {
            let seq_res = parse___(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_forge(input, state, pos);
                        match seq_res {
                            Matched(pos, forge) => {
                                {
                                    let seq_res = parse___(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_modules(input,
                                                                  state, pos);
                                                match seq_res {
                                                    Matched(pos, modules) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        Puppetfile{forge:
                                                                                       forge,
                                                                                   modules:
                                                                                       modules,}
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_forge<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "forge");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_string(input, state, pos);
                                    match seq_res {
                                        Matched(pos, url) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos, { url })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_modules<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Vec<Module>> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res = parse_module(input, state, pos);
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, repeat_value)
    }
}
fn parse_module<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Module> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "mod");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_string(input, state, pos);
                                    match seq_res {
                                        Matched(pos, name) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                match {
                                                                          let seq_res =
                                                                              slice_eq(input,
                                                                                       state,
                                                                                       pos,
                                                                                       ",");
                                                                          match seq_res
                                                                              {
                                                                              Matched(pos,
                                                                                      _)
                                                                              =>
                                                                              {
                                                                                  parse___(input,
                                                                                           state,
                                                                                           pos)
                                                                              }
                                                                              Failed
                                                                              =>
                                                                              Failed,
                                                                          }
                                                                      } {
                                                                    Matched(newpos,
                                                                            value)
                                                                    => {
                                                                        Matched(newpos,
                                                                                Some(value))
                                                                    }
                                                                    Failed =>
                                                                    {
                                                                        Matched(pos,
                                                                                None)
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_module_info(input,
                                                                                              state,
                                                                                              pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    info)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let seq_res =
                                                                                        parse___(input,
                                                                                                 state,
                                                                                                 pos);
                                                                                    match seq_res
                                                                                        {
                                                                                        Matched(pos,
                                                                                                _)
                                                                                        =>
                                                                                        {
                                                                                            {
                                                                                                let match_str =
                                                                                                    input.slice(start_pos,
                                                                                                                pos);
                                                                                                Matched(pos,
                                                                                                        {
                                                                                                            Module{name:
                                                                                                                       name,
                                                                                                                   info:
                                                                                                                       info,}
                                                                                                        })
                                                                                            }
                                                                                        }
                                                                                        Failed
                                                                                        =>
                                                                                        Failed,
                                                                                    }
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_module_info<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<Vec<ModuleInfo>> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let pos =
                            if repeat_value.len() > 0 {
                                let sep_res =
                                    {
                                        let seq_res =
                                            slice_eq(input, state, pos, ",");
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse___(input, state, pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match sep_res {
                                    Matched(newpos, _) => { newpos }
                                    Failed => break ,
                                }
                            } else { pos };
                        let step_res =
                            {
                                let choice_res =
                                    parse_version(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    parse_info_hash(input, state, pos),
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, repeat_value)
                };
            match seq_res {
                Matched(pos, i) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { i })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_version<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<ModuleInfo> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_string(input, state, pos);
            match seq_res {
                Matched(pos, version) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                if semver::Version::parse(version[]).is_ok()
                                                   {
                                                    ModuleInfo::Version(VersionReq::parse(format!("={}"
                                                                                                  ,
                                                                                                  version)[]).unwrap())
                                                } else {
                                                    ModuleInfo::Version(VersionReq::parse(version[]).unwrap())
                                                }
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_info_hash<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<ModuleInfo> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_symbol(input, state, pos);
            match seq_res {
                Matched(pos, key) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "=>");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse___(input, state,
                                                             pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_string(input,
                                                                             state,
                                                                             pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        value)
                                                                => {
                                                                    {
                                                                        let seq_res =
                                                                            parse___(input,
                                                                                     state,
                                                                                     pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                ModuleInfo::Info(key,
                                                                                                                 value)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_symbol<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, ":");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_identifier(input, state, pos);
                        match seq_res {
                            Matched(pos, i) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { i })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_identifier<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let start_pos = pos;
                    {
                        let seq_res =
                            {
                                let choice_res =
                                    parse_letter(input, state, pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "_"),
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let choice_res =
                                                            parse_letter(input,
                                                                         state,
                                                                         pos);
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed => {
                                                                let choice_res =
                                                                    parse_digit(input,
                                                                                state,
                                                                                pos);
                                                                match choice_res
                                                                    {
                                                                    Matched(pos,
                                                                            value)
                                                                    =>
                                                                    Matched(pos,
                                                                            value),
                                                                    Failed =>
                                                                    slice_eq(input,
                                                                             state,
                                                                             pos,
                                                                             "_"),
                                                                }
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, ())
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match_str.to_string()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                };
            match seq_res {
                Matched(pos, chars) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { chars })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_string<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res =
                        parse_doubleQuotedString(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => parse_singleQuotedString(input, state, pos),
                    }
                };
            match seq_res {
                Matched(pos, string) => {
                    {
                        let seq_res = parse___(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { string })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\"");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_doubleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\"");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s[])
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_doubleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let choice_res = parse_simpleDoubleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, state,
                                                            pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleDoubleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState,
                                             pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\"");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedString<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint)
 -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\'");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        parse_singleQuotedCharacter(input,
                                                                    state,
                                                                    pos);
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, s) => {
                                {
                                    let seq_res =
                                        slice_eq(input, state, pos, "\'");
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            String::from_chars(s.as_slice())
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_singleQuotedCharacter<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let choice_res = parse_simpleSingleQuotedCharacter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res =
                    parse_simpleEscapeSequence(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res =
                            parse_zeroEscapeSequence(input, state, pos);
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    parse_hexEscapeSequence(input, state,
                                                            pos);
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let choice_res =
                                            parse_unicodeEscapeSequence(input,
                                                                        state,
                                                                        pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed =>
                                            parse_eolEscapeSequence(input,
                                                                    state,
                                                                    pos),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_simpleSingleQuotedCharacter<'input>(input: &'input str,
                                             state: &mut ParseState,
                                             pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let assert_res =
                        {
                            let choice_res =
                                slice_eq(input, state, pos, "\'");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "\\");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_eolChar(input, state, pos),
                                    }
                                }
                            }
                        };
                    match assert_res {
                        Failed => Matched(pos, ()),
                        Matched(..) => Failed,
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = any_char(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.char_at(0) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_simpleEscapeSequence<'input>(input: &'input str,
                                      state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    {
                                        let choice_res =
                                            parse_digit(input, state, pos);
                                        match choice_res {
                                            Matched(pos, value) =>
                                            Matched(pos, value),
                                            Failed => {
                                                let choice_res =
                                                    slice_eq(input, state,
                                                             pos, "x");
                                                match choice_res {
                                                    Matched(pos, value) =>
                                                    Matched(pos, value),
                                                    Failed => {
                                                        let choice_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     "u");
                                                        match choice_res {
                                                            Matched(pos,
                                                                    value) =>
                                                            Matched(pos,
                                                                    value),
                                                            Failed =>
                                                            parse_eolChar(input,
                                                                          state,
                                                                          pos),
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    };
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res = any_char(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            match match_str.char_at(1)
                                                                {
                                                                'n' => '\n',
                                                                'r' => '\r',
                                                                't' => '\t',
                                                                x => x,
                                                            }
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_zeroEscapeSequence<'input>(input: &'input str,
                                    state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\0");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let assert_res =
                                    parse_digit(input, state, pos);
                                match assert_res {
                                    Failed => Matched(pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { 0u8 as char })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_hexEscapeSequence<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\x");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let match_str =
                                                                input.slice(start_pos,
                                                                            pos);
                                                            Matched(pos,
                                                                    {
                                                                        from_str_radix::<int>(match_str,
                                                                                              16)
                                                                    })
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_unicodeEscapeSequence<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint)
 -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\u");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res =
                            {
                                let start_pos = pos;
                                {
                                    let seq_res =
                                        parse_hexDigit(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    parse_hexDigit(input,
                                                                   state,
                                                                   pos);
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_hexDigit(input,
                                                                               state,
                                                                               pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            parse_hexDigit(input,
                                                                                           state,
                                                                                           pos);
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                from_str_radix::<int>(match_str,
                                                                                                                      16)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            };
                        match seq_res {
                            Matched(pos, value) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos,
                                            {
                                                char::from_u32(value.unwrap()
                                                                   as
                                                                   u32).unwrap()
                                            })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_eolEscapeSequence<'input>(input: &'input str, state: &mut ParseState,
                                   pos: uint) -> ParseResult<char> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "\\");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_eol(input, state, pos);
                        match seq_res {
                            Matched(pos, eol) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { '\n' })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_digit<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '0' ...'9' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9]"),
        }
    } else { state.mark_failure(pos, "[0-9]") }
}
fn parse_hexDigit<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '0' ...'9' | 'a' ...'f' | 'A' ...'F' => Matched(next, ()),
            _ => state.mark_failure(pos, "[0-9a-fA-F]"),
        }
    } else { state.mark_failure(pos, "[0-9a-fA-F]") }
}
fn parse_letter<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let choice_res = parse_lowerCaseLetter(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_upperCaseLetter(input, state, pos),
        }
    }
}
fn parse_lowerCaseLetter<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            'a' ...'z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[a-z]"),
        }
    } else { state.mark_failure(pos, "[a-z]") }
}
fn parse_upperCaseLetter<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            'A' ...'Z' => Matched(next, ()),
            _ => state.mark_failure(pos, "[A-Z]"),
        }
    } else { state.mark_failure(pos, "[A-Z]") }
}
fn parse___<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res =
                {
                    let choice_res = parse_whitespace(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_eol(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => parse_comment(input, state, pos),
                            }
                        }
                    }
                };
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_comment<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let seq_res = slice_eq(input, state, pos, "#");
        match seq_res {
            Matched(pos, _) => {
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            parse_eolChar(input, state, pos);
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        any_char(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_eol<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "\r\n");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, "\r");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => {
                                let choice_res =
                                    slice_eq(input, state, pos, "\u{2028}");
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed =>
                                    slice_eq(input, state, pos, "\u{2029}"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
fn parse_eolChar<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            '\n' | '\r' | '\u{2028}' | '\u{2029}' => Matched(next, ()),
            _ => state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]"),
        }
    } else { state.mark_failure(pos, "[\n\r\u{2028}\u{2029}]") }
}
fn parse_whitespace<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<()> {
    if input.len() > pos {
        let ::std::str::CharRange { ch, next } = input.char_range_at(pos);
        match ch {
            ' ' | '\t' | '\u{a0}' | '\u{feff}' | '\u{1680}' | '\u{180e}' |
            '\u{2000}' ...'\u{200a}' | '\u{202f}' | '\u{205f}' | '\u{3000}' =>
            Matched(next, ()),
            _ =>
            state.mark_failure(pos,
                               "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]"),
        }
    } else {
        state.mark_failure(pos,
                           "[ \t\u{a0}\u{feff}\u{1680}\u{180e}\u{2000}-\u{200a}\u{202f}\u{205f}\u{3000}]")
    }
}
pub fn parse<'input>(input: &'input str) -> Result<Puppetfile, String> {
    let mut state = ParseState::new();
    match parse_parse(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let expected = state.expected.to_string().escape_default();
    Err(format!("Error at {}: Expected {}" , pos_to_line (
                input , state . max_err_pos ) , expected))
}
